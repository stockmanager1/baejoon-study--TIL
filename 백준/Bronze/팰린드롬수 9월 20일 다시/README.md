# 9월 13일 풀이-- 
내가 틀린 이유

접근 방식이 완전히 잘못됨

나는 항상 문제를 풀때 split을 이용해서 풀려고 한다.

예를 들면 121을 [1,2,1]이런 식으로 분리하고 반복문을 돌려서 i번째와 n-i번째를 비교해서 맞다 아니다로 판단했다.

하지만 이 문제는 이런식으로 푸는게 아니라 배열을 역으로 배열해서 이게 처음과 같은지 아닌지를 비교한다.

항상 split을 사용해서 푸는 것 역시 매우 좋은 풀이지만 항상 split이 되는 것은 아니다.

항상 기억하자. split으로 세세히 풀어도 되지만 큰 틀 자체를 바꾸는 방법을 사용하면 때로는 매우 간단하게 문제를 풀 수 있다.

# 9월 30일 풀이

일단 내가 틀린 이유

1. 리스트 슬라이싱에 대해 잘 몰랐다.
2. 계속 split을 기준으로 생각함.
3. 너무 하나하나 쪼개서 생각하려는게 심하다.

보강해야 할 점
1. 리스트 슬라이싱

##리스트 슬라이싱
파이썬 리스트에서 데이터를 접근할 때 하나씩 접근하는 것을 인덱싱, 여러개의 데이터에 접근하는 것을 슬라이싱이라고 한다.



```
>>> kospi_top10 = ['삼성전자', 'SK하이닉스', '현대차', '한국전력', 
'아모레퍼시픽', '제일모직', '삼성전자우', '삼성생명', 'NAVER', '현대모비스']

>>> kospi_top5 = kospi_top10[0:5]
>>> kospi_top5
['삼성전자', 'SK하이닉스', '현대차', '한국전력', '아모레퍼시픽']

>>> kospi_top10[5:9]
['제일모직', '삼성전자우', '삼성생명', 'NAVER']
>>> kospi_top10[5:-1]
['제일모직', '삼성전자우', '삼성생명', 'NAVER']
```
음수로 하면 뒤에서 시작 

## 내가 시도한 코드
```
from collections import Counter
list_A = []
while True:
  A = input()
  A = list(A)
  A = list(map(int,A))
  if len(A) == 1 and 0 in A:
    break
  else:
    B = Counter(A)
    for key, value in B.items():
      if value == 1:
        list_A.append(key)
      else:
        pass
    if len(list_A) >= 2:
      print('no')
      list_A.clear()
    else:
      print('yes')
      list_A.clear()
```
