# [Bronze I] 팰린드롬수 - 1259 

[문제 링크](https://www.acmicpc.net/problem/1259) 

### 성능 요약

메모리: 30840 KB, 시간: 68 ms

### 분류

구현(implementation), 문자열(string)

### 문제 설명

<p>어떤 단어를 뒤에서부터 읽어도 똑같다면 그 단어를 팰린드롬이라고 한다. 'radar', 'sees'는 팰린드롬이다.</p>

<p>수도 팰린드롬으로 취급할 수 있다. 수의 숫자들을 뒤에서부터 읽어도 같다면 그 수는 팰린드롬수다. 121, 12421 등은 팰린드롬수다. 123, 1231은 뒤에서부터 읽으면 다르므로 팰린드롬수가 아니다. 또한 10도 팰린드롬수가 아닌데, 앞에 무의미한 0이 올 수 있다면 010이 되어 팰린드롬수로 취급할 수도 있지만, 특별히 이번 문제에서는 무의미한 0이 앞에 올 수 없다고 하자.</p>

### 입력 

 <p>입력은 여러 개의 테스트 케이스로 이루어져 있으며, 각 줄마다 1 이상 99999 이하의 정수가 주어진다. 입력의 마지막 줄에는 0이 주어지며, 이 줄은 문제에 포함되지 않는다.</p>

### 출력 

 <p>각 줄마다 주어진 수가 팰린드롬수면 'yes', 아니면 'no'를 출력한다.</p>

# 1트: 9월 13일 풀이-- 
내가 틀린 이유

접근 방식이 완전히 잘못됨

나는 항상 문제를 풀때 split을 이용해서 풀려고 한다.

예를 들면 121을 [1,2,1]이런 식으로 분리하고 반복문을 돌려서 i번째와 n-i번째를 비교해서 맞다 아니다로 판단했다.

하지만 이 문제는 이런식으로 푸는게 아니라 배열을 역으로 배열해서 이게 처음과 같은지 아닌지를 비교한다.

항상 split을 사용해서 푸는 것 역시 매우 좋은 풀이지만 항상 split이 되는 것은 아니다.

항상 기억하자. split으로 세세히 풀어도 되지만 큰 틀 자체를 바꾸는 방법을 사용하면 때로는 매우 간단하게 문제를 풀 수 있다.

# 2트: 9월 30일 풀이

일단 내가 틀린 이유

1. 리스트 슬라이싱에 대해 잘 몰랐다.
2. 계속 split을 기준으로 생각함.
3. 너무 하나하나 쪼개서 생각하려는게 심하다.

보강해야 할 점
1. 리스트 슬라이싱

##리스트 슬라이싱
파이썬 리스트에서 데이터를 접근할 때 하나씩 접근하는 것을 인덱싱, 여러개의 데이터에 접근하는 것을 슬라이싱이라고 한다.



```
>>> kospi_top10 = ['삼성전자', 'SK하이닉스', '현대차', '한국전력', 
'아모레퍼시픽', '제일모직', '삼성전자우', '삼성생명', 'NAVER', '현대모비스']

>>> kospi_top5 = kospi_top10[0:5]
>>> kospi_top5
['삼성전자', 'SK하이닉스', '현대차', '한국전력', '아모레퍼시픽']

>>> kospi_top10[5:9]
['제일모직', '삼성전자우', '삼성생명', 'NAVER']
>>> kospi_top10[5:-1]
['제일모직', '삼성전자우', '삼성생명', 'NAVER']
```
음수로 하면 뒤에서 시작 

## 내가 시도한 코드
```
from collections import Counter
list_A = []
while True:
  A = input()
  A = list(A)
  A = list(map(int,A))
  if len(A) == 1 and 0 in A:
    break
  else:
    B = Counter(A)
    for key, value in B.items():
      if value == 1:
        list_A.append(key)
      else:
        pass
    if len(list_A) >= 2:
      print('no')
      list_A.clear()
    else:
      print('yes')
      list_A.clear()
```
# 3트(10월 13일)
```
while True:
  A = input()
  A = list(A)
  list_C = []
  if len(A) == 1 and A[0] == '0':
    break
  else:
    list_A = A[0:len(A)]
    list_B = A[::-1]
    for i,j in zip(list_A,list_B):
      if i != j:
        print('no')
        break
      else:
        list_C.append(i)
      if len(list_C) == len(list_A):
        print('yes')

```
